{"version":3,"sources":["dist/scroller.js"],"names":["global","factory","exports","module","define","amd","Scroller","this","time","Date","now","running","counter","window","Animate","requestAnimationFrame","requestFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","isNative","test","toString","callback","root","requests","rafHandle","intervalHandle","lastActive","callbackHandle","setInterval","currentRequests","key","hasOwnProperty","clearInterval","stop","id","cleared","isRunning","start","stepCallback","verifyCallback","completedCallback","duration","easingMethod","lastFrame","percent","dropCounter","document","body","newRunning","usedId","step","virtual","render","droppedFrames","Math","round","j","min","value","NOOP","easeOutCubic","pos","pow","easeInOutCubic","members","__isSingleTouch","options","__callback","scrollingX","scrollingY","animating","animationDuration","bouncing","locking","paging","snapping","zooming","minZoom","maxZoom","speedMultiplier","scrollingComplete","penetrationDeceleration","penetrationAcceleration","__isTracking","__didDecelerationComplete","__isGesturing","__isDragging","__isDecelerating","__isAnimating","__clientLeft","__clientTop","__clientWidth","__clientHeight","__contentWidth","__contentHeight","__snapWidth","__snapHeight","__refreshHeight","__refreshActive","__refreshActivate","__refreshDeactivate","__refreshStart","__zoomLevel","__scrollLeft","__scrollTop","__maxScrollLeft","__maxScrollTop","__scheduledLeft","__scheduledTop","__scheduledZoom","__lastTouchLeft","__lastTouchTop","__lastTouchMove","__positions","__minDecelerationScrollLeft","__minDecelerationScrollTop","__maxDecelerationScrollLeft","__maxDecelerationScrollTop","__decelerationVelocityX","__decelerationVelocityY","setDimensions","clientWidth","clientHeight","contentWidth","contentHeight","self","__computeScrollMax","scrollTo","setPosition","left","top","setSnapSize","width","height","activatePullToRefresh","activateCallback","deactivateCallback","startCallback","triggerPullToRefresh","__publish","finishPullToRefresh","getValues","zoom","getScrollMax","zoomTo","level","animate","originLeft","originTop","Error","__zoomComplete","oldLevel","max","zoomBy","factor","scrollBy","startLeft","startTop","doMouseZoom","wheelDelta","timeStamp","pageX","pageY","change","doTouchStart","touches","length","valueOf","currentTouchLeft","currentTouchTop","__interruptedAnimation","isSingleTouch","abs","__initialTouchLeft","__initialTouchTop","__zoomLevelStart","__lastScale","__enableScrollX","__enableScrollY","doTouchMove","scale","positions","moveX","moveY","scrollLeft","scrollTop","currentTouchLeftRel","currentTouchTopRel","maxScrollLeft","maxScrollTop","splice","push","minimumTrackingForScroll","distanceX","distanceY","doTouchEnd","endPos","startPos","i","timeOffset","movedLeft","movedTop","minVelocityToStartDeceleration","__startDeceleration","wasAnimating","oldLeft","oldTop","oldZoom","diffLeft","diffTop","diffZoom","renderedFramesPerSecond","animationId","wasFinished","zoomLevel","floor","ceil","minVelocityToKeepDecelerating","__stepThroughDeceleration","shouldContinue","scrollLeftFixed","scrollTopFixed","scrollOutsideX","scrollOutsideY","prototype","Scroller$1","EasyScroller","content","container","parentNode","that","scroller","bindEvents","style","vendorPrefix","reflow","offsetWidth","offsetHeight","rect","getBoundingClientRect","clientLeft","clientTop","addEventListener","e","target","tagName","match","preventDefault","mousedown"],"mappings":"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","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.Scroller = {})));\n}(this, (function (exports) { 'use strict';\n\n  /*\n   * Scroller\n   * http://github.com/zynga/scroller\n   *\n   * Copyright 2011, Zynga Inc.\n   * Licensed under the MIT License.\n   * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n   *\n   * Based on the work of: Unify Project (unify-project.org)\n   * http://unify-project.org\n   * Copyright 2011, Deutsche Telekom AG\n   * License: MIT + Apache (V2)\n   */\n\n  /**\n   * Generic animation class with support for dropped frames both optional easing and duration.\n   *\n   * Optional duration is useful when the lifetime is defined by another condition than time\n   * e.g. speed of an animating object, etc.\n   *\n   * Dropped frame logic allows to keep using the same updater logic independent from the actual\n   * rendering. This eases a lot of cases where it might be pretty complex to break down a state\n   * based on the pure time difference.\n   */\n  var time = Date.now || function () {\n    return +new Date()\n  };\n  var desiredFrames = 60;\n  var millisecondsPerSecond = 1000;\n  var running = {};\n  var counter = 1;\n\n  var global = window;\n\n  var Animate = {\n\n    /**\n     * A requestAnimationFrame wrapper / polyfill.\n     *\n     * @param callback {Function} The callback to be invoked before the next repaint.\n     * @param root {HTMLElement} The root element for the repaint\n     */\n    requestAnimationFrame: (function () {\n      // Check for request animation Frame support\n      var requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;\n      var isNative = !!requestFrame;\n\n      if (requestFrame && !/requestAnimationFrame\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}/i.test(requestFrame.toString())) {\n        isNative = false;\n      }\n\n      if (isNative) {\n        return function (callback, root) {\n          requestFrame(callback, root);\n        }\n      }\n\n      var TARGET_FPS = 60;\n      var requests = {};\n      var rafHandle = 1;\n      var intervalHandle = null;\n      var lastActive = +new Date();\n\n      return function (callback, root) {\n        var callbackHandle = rafHandle++;\n\n        // Store callback\n        requests[callbackHandle] = callback;\n\n        // Create timeout at first request\n        if (intervalHandle === null) {\n          intervalHandle = setInterval(function () {\n            var time = +new Date();\n            var currentRequests = requests;\n\n            // Reset data structure before executing callbacks\n            requests = {};\n\n            for (var key in currentRequests) {\n              if (currentRequests.hasOwnProperty(key)) {\n                currentRequests[key](time);\n                lastActive = time;\n              }\n            }\n\n            // Disable the timeout when nothing happens for a certain\n            // period of time\n            if (time - lastActive > 2500) {\n              clearInterval(intervalHandle);\n              intervalHandle = null;\n            }\n          }, 1000 / TARGET_FPS);\n        }\n\n        return callbackHandle\n      }\n    })(),\n\n    /**\n     * Stops the given animation.\n     *\n     * @param id {Integer} Unique animation ID\n     * @return {Boolean} Whether the animation was stopped (aka, was running before)\n     */\n    stop: function (id) {\n      var cleared = running[id] != null;\n      if (cleared) {\n        running[id] = null;\n      }\n\n      return cleared\n    },\n\n    /**\n     * Whether the given animation is still running.\n     *\n     * @param id {Integer} Unique animation ID\n     * @return {Boolean} Whether the animation is still running\n     */\n    isRunning: function (id) {\n      return running[id] != null\n    },\n\n    /**\n     * Start the animation.\n     *\n     * @param stepCallback {Function} Pointer to function which is executed on every step.\n     *   Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`\n     * @param verifyCallback {Function} Executed before every animation step.\n     *   Signature of the method should be `function() { return continueWithAnimation; }`\n     * @param completedCallback {Function}\n     *   Signature of the method should be `function(droppedFrames, finishedAnimation) {}`\n     * @param duration {Integer} Milliseconds to run the animation\n     * @param easingMethod {Function} Pointer to easing function\n     *   Signature of the method should be `function(percent) { return modifiedValue; }`\n     * @param root {Element ? document.body} Render root, when available. Used for internal\n     *   usage of requestAnimationFrame.\n     * @return {Integer} Identifier of animation. Can be used to stop it any time.\n     */\n    start: function (stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {\n      var start = time();\n      var lastFrame = start;\n      var percent = 0;\n      var dropCounter = 0;\n      var id = counter++;\n\n      if (!root) {\n        root = document.body;\n      }\n\n      // Compacting running db automatically every few new animations\n      if (id % 20 === 0) {\n        var newRunning = {};\n        for (var usedId in running) {\n          newRunning[usedId] = true;\n        }\n        running = newRunning;\n      }\n\n      // This is the internal step method which is called every few milliseconds\n      var step = function (virtual) {\n        // Normalize virtual value\n        var render = virtual !== true;\n\n        // Get current time\n        var now = time();\n\n        // Verification is executed before next animation step\n        if (!running[id] || (verifyCallback && !verifyCallback(id))) {\n          running[id] = null;\n          completedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, false);\n          return\n        }\n\n        // For the current rendering to apply let's update omitted steps in memory.\n        // This is important to bring internal state variables up-to-date with progress in time.\n        if (render) {\n          var droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1;\n          for (var j = 0; j < Math.min(droppedFrames, 4); j++) {\n            step(true);\n            dropCounter++;\n          }\n        }\n\n        // Compute percent value\n        if (duration) {\n          percent = (now - start) / duration;\n          if (percent > 1) {\n            percent = 1;\n          }\n        }\n\n        // Execute step callback, then...\n        var value = easingMethod ? easingMethod(percent) : percent;\n        if ((stepCallback(value, now, render) === false || percent === 1) && render) {\n          running[id] = null;\n          completedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, percent === 1 || duration == null);\n        } else if (render) {\n          lastFrame = now;\n          Animate.requestAnimationFrame(step, root);\n        }\n      };\n\n      // Mark as running\n      running[id] = true;\n\n      // Init first step\n      Animate.requestAnimationFrame(step, root);\n\n      // Return unique animation ID\n      return id\n    }\n  };\n\n  /*\n   * Scroller\n   * http://github.com/zynga/scroller\n   *\n   * Copyright 2011, Zynga Inc.\n   * Licensed under the MIT License.\n   * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n   *\n   * Based on the work of: Unify Project (unify-project.org)\n   * http://unify-project.org\n   * Copyright 2011, Deutsche Telekom AG\n   * License: MIT + Apache (V2)\n   */\n\n  var Scroller;\n\n  var NOOP = function () { };\n\n  /**\n   * A pure logic 'component' for 'virtual' scrolling/zooming.\n   */\n  Scroller = function (callback, options) {\n    this.__callback = callback;\n\n    this.options = {\n\n      /** Enable scrolling on x-axis */\n      scrollingX: true,\n\n      /** Enable scrolling on y-axis */\n      scrollingY: true,\n\n      /** Enable animations for deceleration, snap back, zooming and scrolling */\n      animating: true,\n\n      /** duration for animations triggered by scrollTo/zoomTo */\n      animationDuration: 250,\n\n      /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\n      bouncing: true,\n\n      /** Enable locking to the main axis if user moves only slightly on one of them at start */\n      locking: true,\n\n      /** Enable pagination mode (switching between full page content panes) */\n      paging: false,\n\n      /** Enable snapping of content to a configured pixel grid */\n      snapping: false,\n\n      /** Enable zooming of content via API, fingers and mouse wheel */\n      zooming: false,\n\n      /** Minimum zoom level */\n      minZoom: 0.5,\n\n      /** Maximum zoom level */\n      maxZoom: 3,\n\n      /** Multiply or decrease scrolling speed **/\n      speedMultiplier: 1,\n\n      /** Callback that is fired on the later of touch end or deceleration end,\n        provided that another scrolling action has not begun. Used to know\n        when to fade out a scrollbar. */\n      scrollingComplete: NOOP,\n\n      /** This configures the amount of change applied to deceleration when reaching boundaries  **/\n      penetrationDeceleration: 0.03,\n\n      /** This configures the amount of change applied to acceleration when reaching boundaries  **/\n      penetrationAcceleration: 0.08\n\n    };\n\n    for (var key in options) {\n      this.options[key] = options[key];\n    }\n  };\n\n  // Easing Equations (c) 2003 Robert Penner, all rights reserved.\n  // Open source under the BSD License.\n\n  /**\n   * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\n  **/\n  var easeOutCubic = function (pos) {\n    return (Math.pow((pos - 1), 3) + 1)\n  };\n\n  /**\n   * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\n  **/\n  var easeInOutCubic = function (pos) {\n    if ((pos /= 0.5) < 1) {\n      return 0.5 * Math.pow(pos, 3)\n    }\n\n    return 0.5 * (Math.pow((pos - 2), 3) + 2)\n  };\n\n  var members = {\n\n    /*\n    ---------------------------------------------------------------------------\n      INTERNAL FIELDS :: STATUS\n    ---------------------------------------------------------------------------\n    */\n\n    /** {Boolean} Whether only a single finger is used in touch handling */\n    __isSingleTouch: false,\n\n    /** {Boolean} Whether a touch event sequence is in progress */\n    __isTracking: false,\n\n    /** {Boolean} Whether a deceleration animation went to completion. */\n    __didDecelerationComplete: false,\n\n    /**\n     * {Boolean} Whether a gesture zoom/rotate event is in progress. Activates when\n     * a gesturestart event happens. This has higher priority than dragging.\n     */\n    __isGesturing: false,\n\n    /**\n     * {Boolean} Whether the user has moved by such a distance that we have enabled\n     * dragging mode. Hint: It's only enabled after some pixels of movement to\n     * not interrupt with clicks etc.\n     */\n    __isDragging: false,\n\n    /**\n     * {Boolean} Not touching and dragging anymore, and smoothly animating the\n     * touch sequence using deceleration.\n     */\n    __isDecelerating: false,\n\n    /**\n     * {Boolean} Smoothly animating the currently configured change\n     */\n    __isAnimating: false,\n\n    /*\n    ---------------------------------------------------------------------------\n      INTERNAL FIELDS :: DIMENSIONS\n    ---------------------------------------------------------------------------\n    */\n\n    /** {Integer} Available outer left position (from document perspective) */\n    __clientLeft: 0,\n\n    /** {Integer} Available outer top position (from document perspective) */\n    __clientTop: 0,\n\n    /** {Integer} Available outer width */\n    __clientWidth: 0,\n\n    /** {Integer} Available outer height */\n    __clientHeight: 0,\n\n    /** {Integer} Outer width of content */\n    __contentWidth: 0,\n\n    /** {Integer} Outer height of content */\n    __contentHeight: 0,\n\n    /** {Integer} Snapping width for content */\n    __snapWidth: 100,\n\n    /** {Integer} Snapping height for content */\n    __snapHeight: 100,\n\n    /** {Integer} Height to assign to refresh area */\n    __refreshHeight: null,\n\n    /** {Boolean} Whether the refresh process is enabled when the event is released now */\n    __refreshActive: false,\n\n    /** {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release */\n    __refreshActivate: null,\n\n    /** {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled */\n    __refreshDeactivate: null,\n\n    /** {Function} Callback to execute to start the actual refresh. Call {@link #refreshFinish} when done */\n    __refreshStart: null,\n\n    /** {Number} Zoom level */\n    __zoomLevel: 1,\n\n    /** {Number} Scroll position on x-axis */\n    __scrollLeft: 0,\n\n    /** {Number} Scroll position on y-axis */\n    __scrollTop: 0,\n\n    /** {Integer} Maximum allowed scroll position on x-axis */\n    __maxScrollLeft: 0,\n\n    /** {Integer} Maximum allowed scroll position on y-axis */\n    __maxScrollTop: 0,\n\n    /* {Number} Scheduled left position (final position when animating) */\n    __scheduledLeft: 0,\n\n    /* {Number} Scheduled top position (final position when animating) */\n    __scheduledTop: 0,\n\n    /* {Number} Scheduled zoom level (final scale when animating) */\n    __scheduledZoom: 0,\n\n    /*\n    ---------------------------------------------------------------------------\n      INTERNAL FIELDS :: LAST POSITIONS\n    ---------------------------------------------------------------------------\n    */\n\n    /** {Number} Left position of finger at start */\n    __lastTouchLeft: null,\n\n    /** {Number} Top position of finger at start */\n    __lastTouchTop: null,\n\n    /** {Date} Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */\n    __lastTouchMove: null,\n\n    /** {Array} List of positions, uses three indexes for each state: left, top, timestamp */\n    __positions: null,\n\n    /*\n    ---------------------------------------------------------------------------\n      INTERNAL FIELDS :: DECELERATION SUPPORT\n    ---------------------------------------------------------------------------\n    */\n\n    /** {Integer} Minimum left scroll position during deceleration */\n    __minDecelerationScrollLeft: null,\n\n    /** {Integer} Minimum top scroll position during deceleration */\n    __minDecelerationScrollTop: null,\n\n    /** {Integer} Maximum left scroll position during deceleration */\n    __maxDecelerationScrollLeft: null,\n\n    /** {Integer} Maximum top scroll position during deceleration */\n    __maxDecelerationScrollTop: null,\n\n    /** {Number} Current factor to modify horizontal scroll position with on every step */\n    __decelerationVelocityX: null,\n\n    /** {Number} Current factor to modify vertical scroll position with on every step */\n    __decelerationVelocityY: null,\n\n    /*\n    ---------------------------------------------------------------------------\n      PUBLIC API\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Configures the dimensions of the client (outer) and content (inner) elements.\n     * Requires the available space for the outer element and the outer size of the inner element.\n     * All values which are falsy (null or zero etc.) are ignored and the old value is kept.\n     *\n     * @param clientWidth {Integer ? null} Inner width of outer element\n     * @param clientHeight {Integer ? null} Inner height of outer element\n     * @param contentWidth {Integer ? null} Outer width of inner element\n     * @param contentHeight {Integer ? null} Outer height of inner element\n     */\n    setDimensions: function (clientWidth, clientHeight, contentWidth, contentHeight) {\n      var self = this;\n\n      // Only update values which are defined\n      if (clientWidth === +clientWidth) {\n        self.__clientWidth = clientWidth;\n      }\n\n      if (clientHeight === +clientHeight) {\n        self.__clientHeight = clientHeight;\n      }\n\n      if (contentWidth === +contentWidth) {\n        self.__contentWidth = contentWidth;\n      }\n\n      if (contentHeight === +contentHeight) {\n        self.__contentHeight = contentHeight;\n      }\n\n      // Refresh maximums\n      self.__computeScrollMax();\n\n      // Refresh scroll position\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n    },\n\n    /**\n     * Sets the client coordinates in relation to the document.\n     *\n     * @param left {Integer ? 0} Left position of outer element\n     * @param top {Integer ? 0} Top position of outer element\n     */\n    setPosition: function (left, top) {\n      var self = this;\n\n      self.__clientLeft = left || 0;\n      self.__clientTop = top || 0;\n    },\n\n    /**\n     * Configures the snapping (when snapping is active)\n     *\n     * @param width {Integer} Snapping width\n     * @param height {Integer} Snapping height\n     */\n    setSnapSize: function (width, height) {\n      var self = this;\n\n      self.__snapWidth = width;\n      self.__snapHeight = height;\n    },\n\n    /**\n     * Activates pull-to-refresh. A special zone on the top of the list to start a list refresh whenever\n     * the user event is released during visibility of this zone. This was introduced by some apps on iOS like\n     * the official Twitter client.\n     *\n     * @param height {Integer} Height of pull-to-refresh zone on top of rendered list\n     * @param activateCallback {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release.\n     * @param deactivateCallback {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled.\n     * @param startCallback {Function} Callback to execute to start the real async refresh action. Call {@link #finishPullToRefresh} after finish of refresh.\n     */\n    activatePullToRefresh: function (height, activateCallback, deactivateCallback, startCallback) {\n      var self = this;\n\n      self.__refreshHeight = height;\n      self.__refreshActivate = activateCallback;\n      self.__refreshDeactivate = deactivateCallback;\n      self.__refreshStart = startCallback;\n    },\n\n    /**\n     * Starts pull-to-refresh manually.\n     */\n    triggerPullToRefresh: function () {\n      // Use publish instead of scrollTo to allow scrolling to out of boundary position\n      // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n      this.__publish(this.__scrollLeft, -this.__refreshHeight, this.__zoomLevel, true);\n\n      if (this.__refreshStart) {\n        this.__refreshStart();\n      }\n    },\n\n    /**\n     * Signalizes that pull-to-refresh is finished.\n     */\n    finishPullToRefresh: function () {\n      var self = this;\n\n      self.__refreshActive = false;\n      if (self.__refreshDeactivate) {\n        self.__refreshDeactivate();\n      }\n\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n    },\n\n    /**\n     * Returns the scroll position and zooming values\n     *\n     * @return {Map} `left` and `top` scroll position and `zoom` level\n     */\n    getValues: function () {\n      var self = this;\n\n      return {\n        left: self.__scrollLeft,\n        top: self.__scrollTop,\n        zoom: self.__zoomLevel\n      }\n    },\n\n    /**\n     * Returns the maximum scroll values\n     *\n     * @return {Map} `left` and `top` maximum scroll values\n     */\n    getScrollMax: function () {\n      var self = this;\n\n      return {\n        left: self.__maxScrollLeft,\n        top: self.__maxScrollTop\n      }\n    },\n\n    /**\n     * Zooms to the given level. Supports optional animation. Zooms\n     * the center when no coordinates are given.\n     *\n     * @param level {Number} Level to zoom to\n     * @param animate {Boolean ? false} Whether to use animation\n     * @param originLeft {Number ? null} Zoom in at given left coordinate\n     * @param originTop {Number ? null} Zoom in at given top coordinate\n     * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n     */\n    zoomTo: function (level, animate, originLeft, originTop, callback) {\n      var self = this;\n\n      if (!self.options.zooming) {\n        throw new Error('Zooming is not enabled!')\n      }\n\n      // Add callback if exists\n      if (callback) {\n        self.__zoomComplete = callback;\n      }\n\n      // Stop deceleration\n      if (self.__isDecelerating) {\n        Animate.stop(self.__isDecelerating);\n        self.__isDecelerating = false;\n      }\n\n      var oldLevel = self.__zoomLevel;\n\n      // Normalize input origin to center of viewport if not defined\n      if (originLeft == null) {\n        originLeft = self.__clientWidth / 2;\n      }\n\n      if (originTop == null) {\n        originTop = self.__clientHeight / 2;\n      }\n\n      // Limit level according to configuration\n      level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);\n\n      // Recompute maximum values while temporary tweaking maximum scroll ranges\n      self.__computeScrollMax(level);\n\n      // Recompute left and top coordinates based on new zoom level\n      var left = ((originLeft + self.__scrollLeft) * level / oldLevel) - originLeft;\n      var top = ((originTop + self.__scrollTop) * level / oldLevel) - originTop;\n\n      // Limit x-axis\n      if (left > self.__maxScrollLeft) {\n        left = self.__maxScrollLeft;\n      } else if (left < 0) {\n        left = 0;\n      }\n\n      // Limit y-axis\n      if (top > self.__maxScrollTop) {\n        top = self.__maxScrollTop;\n      } else if (top < 0) {\n        top = 0;\n      }\n\n      // Push values out\n      self.__publish(left, top, level, animate);\n    },\n\n    /**\n     * Zooms the content by the given factor.\n     *\n     * @param factor {Number} Zoom by given factor\n     * @param animate {Boolean ? false} Whether to use animation\n     * @param originLeft {Number ? 0} Zoom in at given left coordinate\n     * @param originTop {Number ? 0} Zoom in at given top coordinate\n     * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n     */\n    zoomBy: function (factor, animate, originLeft, originTop, callback) {\n      var self = this;\n\n      self.zoomTo(self.__zoomLevel * factor, animate, originLeft, originTop, callback);\n    },\n\n    /**\n     * Scrolls to the given position. Respect limitations and snapping automatically.\n     *\n     * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>\n     * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>\n     * @param animate {Boolean?false} Whether the scrolling should happen using an animation\n     * @param zoom {Number?null} Zoom level to go to\n     */\n    scrollTo: function (left, top, animate, zoom) {\n      var self = this;\n\n      // Stop deceleration\n      if (self.__isDecelerating) {\n        Animate.stop(self.__isDecelerating);\n        self.__isDecelerating = false;\n      }\n\n      // Correct coordinates based on new zoom level\n      if (zoom != null && zoom !== self.__zoomLevel) {\n        if (!self.options.zooming) {\n          throw new Error('Zooming is not enabled!')\n        }\n\n        left *= zoom;\n        top *= zoom;\n\n        // Recompute maximum values while temporary tweaking maximum scroll ranges\n        self.__computeScrollMax(zoom);\n      } else {\n        // Keep zoom when not defined\n        zoom = self.__zoomLevel;\n      }\n\n      if (!self.options.scrollingX) {\n        left = self.__scrollLeft;\n      } else {\n        if (self.options.paging) {\n          left = Math.round(left / self.__clientWidth) * self.__clientWidth;\n        } else if (self.options.snapping) {\n          left = Math.round(left / self.__snapWidth) * self.__snapWidth;\n        }\n      }\n\n      if (!self.options.scrollingY) {\n        top = self.__scrollTop;\n      } else {\n        if (self.options.paging) {\n          top = Math.round(top / self.__clientHeight) * self.__clientHeight;\n        } else if (self.options.snapping) {\n          top = Math.round(top / self.__snapHeight) * self.__snapHeight;\n        }\n      }\n\n      // Limit for allowed ranges\n      left = Math.max(Math.min(self.__maxScrollLeft, left), 0);\n      top = Math.max(Math.min(self.__maxScrollTop, top), 0);\n\n      // Don't animate when no change detected, still call publish to make sure\n      // that rendered position is really in-sync with internal data\n      if (left === self.__scrollLeft && top === self.__scrollTop) {\n        animate = false;\n      }\n\n      // Publish new values\n      if (!self.__isTracking) {\n        self.__publish(left, top, zoom, animate);\n      }\n    },\n\n    /**\n     * Scroll by the given offset\n     *\n     * @param left {Number ? 0} Scroll x-axis by given offset\n     * @param top {Number ? 0} Scroll x-axis by given offset\n     * @param animate {Boolean ? false} Whether to animate the given change\n     */\n    scrollBy: function (left, top, animate) {\n      var self = this;\n\n      var startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;\n      var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;\n\n      self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n      EVENT CALLBACKS\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Mouse wheel handler for zooming support\n     */\n    doMouseZoom: function (wheelDelta, timeStamp, pageX, pageY) {\n      var self = this;\n      var change = wheelDelta > 0 ? 0.97 : 1.03;\n\n      return self.zoomTo(self.__zoomLevel * change, false, pageX - self.__clientLeft, pageY - self.__clientTop)\n    },\n\n    /**\n     * Touch start handler for scrolling support\n     */\n    doTouchStart: function (touches, timeStamp) {\n      // Array-like check is enough here\n      if (touches.length == null) {\n        throw new Error('Invalid touch list: ' + touches)\n      }\n\n      if (timeStamp instanceof Date) {\n        timeStamp = timeStamp.valueOf();\n      }\n      if (typeof timeStamp !== 'number') {\n        throw new Error('Invalid timestamp value: ' + timeStamp)\n      }\n\n      var self = this;\n\n      // Reset interruptedAnimation flag\n      self.__interruptedAnimation = true;\n\n      // Stop deceleration\n      if (self.__isDecelerating) {\n        Animate.stop(self.__isDecelerating);\n        self.__isDecelerating = false;\n        self.__interruptedAnimation = true;\n      }\n\n      // Stop animation\n      if (self.__isAnimating) {\n        Animate.stop(self.__isAnimating);\n        self.__isAnimating = false;\n        self.__interruptedAnimation = true;\n      }\n\n      // Use center point when dealing with two fingers\n      var currentTouchLeft, currentTouchTop;\n      var isSingleTouch = touches.length === 1;\n      if (isSingleTouch) {\n        currentTouchLeft = touches[0].pageX;\n        currentTouchTop = touches[0].pageY;\n      } else {\n        currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n        currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n      }\n\n      // Store initial positions\n      self.__initialTouchLeft = currentTouchLeft;\n      self.__initialTouchTop = currentTouchTop;\n\n      // Store current zoom level\n      self.__zoomLevelStart = self.__zoomLevel;\n\n      // Store initial touch positions\n      self.__lastTouchLeft = currentTouchLeft;\n      self.__lastTouchTop = currentTouchTop;\n\n      // Store initial move time stamp\n      self.__lastTouchMove = timeStamp;\n\n      // Reset initial scale\n      self.__lastScale = 1;\n\n      // Reset locking flags\n      self.__enableScrollX = !isSingleTouch && self.options.scrollingX;\n      self.__enableScrollY = !isSingleTouch && self.options.scrollingY;\n\n      // Reset tracking flag\n      self.__isTracking = true;\n\n      // Reset deceleration complete flag\n      self.__didDecelerationComplete = false;\n\n      // Dragging starts directly with two fingers, otherwise lazy with an offset\n      self.__isDragging = !isSingleTouch;\n\n      // Some features are disabled in multi touch scenarios\n      self.__isSingleTouch = isSingleTouch;\n\n      // Clearing data structure\n      self.__positions = [];\n    },\n\n    /**\n     * Touch move handler for scrolling support\n     */\n    doTouchMove: function (touches, timeStamp, scale) {\n      // Array-like check is enough here\n      if (touches.length == null) {\n        throw new Error('Invalid touch list: ' + touches)\n      }\n\n      if (timeStamp instanceof Date) {\n        timeStamp = timeStamp.valueOf();\n      }\n      if (typeof timeStamp !== 'number') {\n        throw new Error('Invalid timestamp value: ' + timeStamp)\n      }\n\n      var self = this;\n\n      // Ignore event when tracking is not enabled (event might be outside of element)\n      if (!self.__isTracking) {\n        return\n      }\n\n      var currentTouchLeft, currentTouchTop;\n\n      // Compute move based around of center of fingers\n      if (touches.length === 2) {\n        currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n        currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n      } else {\n        currentTouchLeft = touches[0].pageX;\n        currentTouchTop = touches[0].pageY;\n      }\n\n      var positions = self.__positions;\n\n      // Are we already is dragging mode?\n      if (self.__isDragging) {\n        // Compute move distance\n        var moveX = currentTouchLeft - self.__lastTouchLeft;\n        var moveY = currentTouchTop - self.__lastTouchTop;\n\n        // Read previous scroll position and zooming\n        var scrollLeft = self.__scrollLeft;\n        var scrollTop = self.__scrollTop;\n        var level = self.__zoomLevel;\n\n        // Work with scaling\n        if (scale != null && self.options.zooming) {\n          var oldLevel = level;\n\n          // Recompute level based on previous scale and new scale\n          level = level / self.__lastScale * scale;\n\n          // Limit level according to configuration\n          level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);\n\n          // Only do further compution when change happened\n          if (oldLevel !== level) {\n            // Compute relative event position to container\n            var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;\n            var currentTouchTopRel = currentTouchTop - self.__clientTop;\n\n            // Recompute left and top coordinates based on new zoom level\n            scrollLeft = ((currentTouchLeftRel + scrollLeft) * level / oldLevel) - currentTouchLeftRel;\n            scrollTop = ((currentTouchTopRel + scrollTop) * level / oldLevel) - currentTouchTopRel;\n\n            // Recompute max scroll values\n            self.__computeScrollMax(level);\n          }\n        }\n\n        if (self.__enableScrollX) {\n          scrollLeft -= moveX * this.options.speedMultiplier;\n          var maxScrollLeft = self.__maxScrollLeft;\n\n          if (scrollLeft > maxScrollLeft || scrollLeft < 0) {\n            // Slow down on the edges\n            if (self.options.bouncing) {\n              scrollLeft += (moveX / 2 * this.options.speedMultiplier);\n            } else if (scrollLeft > maxScrollLeft) {\n              scrollLeft = maxScrollLeft;\n            } else {\n              scrollLeft = 0;\n            }\n          }\n        }\n\n        // Compute new vertical scroll position\n        if (self.__enableScrollY) {\n          scrollTop -= moveY * this.options.speedMultiplier;\n          var maxScrollTop = self.__maxScrollTop;\n\n          if (scrollTop > maxScrollTop || scrollTop < 0) {\n            // Slow down on the edges\n            if (self.options.bouncing) {\n              scrollTop += (moveY / 2 * this.options.speedMultiplier);\n\n              // Support pull-to-refresh (only when only y is scrollable)\n              if (!self.__enableScrollX && self.__refreshHeight != null) {\n                if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {\n                  self.__refreshActive = true;\n                  if (self.__refreshActivate) {\n                    self.__refreshActivate();\n                  }\n                } else if (self.__refreshActive && scrollTop > -self.__refreshHeight) {\n                  self.__refreshActive = false;\n                  if (self.__refreshDeactivate) {\n                    self.__refreshDeactivate();\n                  }\n                }\n              }\n            } else if (scrollTop > maxScrollTop) {\n              scrollTop = maxScrollTop;\n            } else {\n              scrollTop = 0;\n            }\n          }\n        }\n\n        // Keep list from growing infinitely (holding min 10, max 20 measure points)\n        if (positions.length > 60) {\n          positions.splice(0, 30);\n        }\n\n        // Track scroll movement for decleration\n        positions.push(scrollLeft, scrollTop, timeStamp);\n\n        // Sync scroll position\n        self.__publish(scrollLeft, scrollTop, level);\n\n        // Otherwise figure out whether we are switching into dragging mode now.\n      } else {\n        var minimumTrackingForScroll = self.options.locking ? 3 : 0;\n        var minimumTrackingForDrag = 5;\n\n        var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);\n        var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);\n\n        self.__enableScrollX = self.options.scrollingX && distanceX >= minimumTrackingForScroll;\n        self.__enableScrollY = self.options.scrollingY && distanceY >= minimumTrackingForScroll;\n\n        positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);\n\n        self.__isDragging = (self.__enableScrollX || self.__enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);\n        if (self.__isDragging) {\n          self.__interruptedAnimation = false;\n        }\n      }\n\n      // Update last touch positions and time stamp for next event\n      self.__lastTouchLeft = currentTouchLeft;\n      self.__lastTouchTop = currentTouchTop;\n      self.__lastTouchMove = timeStamp;\n      self.__lastScale = scale;\n    },\n\n    /**\n     * Touch end handler for scrolling support\n     */\n    doTouchEnd: function (timeStamp) {\n      if (timeStamp instanceof Date) {\n        timeStamp = timeStamp.valueOf();\n      }\n      if (typeof timeStamp !== 'number') {\n        throw new Error('Invalid timestamp value: ' + timeStamp)\n      }\n\n      var self = this;\n\n      // Ignore event when tracking is not enabled (no touchstart event on element)\n      // This is required as this listener ('touchmove') sits on the document and not on the element itself.\n      if (!self.__isTracking) {\n        return\n      }\n\n      // Not touching anymore (when two finger hit the screen there are two touch end events)\n      self.__isTracking = false;\n\n      // Be sure to reset the dragging flag now. Here we also detect whether\n      // the finger has moved fast enough to switch into a deceleration animation.\n      if (self.__isDragging) {\n        // Reset dragging flag\n        self.__isDragging = false;\n\n        // Start deceleration\n        // Verify that the last move detected was in some relevant time frame\n        if (self.__isSingleTouch && self.options.animating && (timeStamp - self.__lastTouchMove) <= 100) {\n          // Then figure out what the scroll position was about 100ms ago\n          var positions = self.__positions;\n          var endPos = positions.length - 1;\n          var startPos = endPos;\n\n          // Move pointer to position measured 100ms ago\n          for (var i = endPos; i > 0 && positions[i] > (self.__lastTouchMove - 100); i -= 3) {\n            startPos = i;\n          }\n\n          // If start and stop position is identical in a 100ms timeframe,\n          // we cannot compute any useful deceleration.\n          if (startPos !== endPos) {\n            // Compute relative movement between these two points\n            var timeOffset = positions[endPos] - positions[startPos];\n            var movedLeft = self.__scrollLeft - positions[startPos - 2];\n            var movedTop = self.__scrollTop - positions[startPos - 1];\n\n            // Based on 50ms compute the movement to apply for each render step\n            self.__decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);\n            self.__decelerationVelocityY = movedTop / timeOffset * (1000 / 60);\n\n            // How much velocity is required to start the deceleration\n            var minVelocityToStartDeceleration = self.options.paging || self.options.snapping ? 4 : 1;\n\n            // Verify that we have enough velocity to start deceleration\n            if (Math.abs(self.__decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(self.__decelerationVelocityY) > minVelocityToStartDeceleration) {\n              // Deactivate pull-to-refresh when decelerating\n              if (!self.__refreshActive) {\n                self.__startDeceleration(timeStamp);\n              }\n            } else {\n              self.options.scrollingComplete();\n            }\n          } else {\n            self.options.scrollingComplete();\n          }\n        } else if ((timeStamp - self.__lastTouchMove) > 100) {\n          self.options.scrollingComplete();\n        }\n      }\n\n      // If this was a slower move it is per default non decelerated, but this\n      // still means that we want snap back to the bounds which is done here.\n      // This is placed outside the condition above to improve edge case stability\n      // e.g. touchend fired without enabled dragging. This should normally do not\n      // have modified the scroll positions or even showed the scrollbars though.\n      if (!self.__isDecelerating) {\n        if (self.__refreshActive && self.__refreshStart) {\n          // Use publish instead of scrollTo to allow scrolling to out of boundary position\n          // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n          self.__publish(self.__scrollLeft, -self.__refreshHeight, self.__zoomLevel, true);\n\n          if (self.__refreshStart) {\n            self.__refreshStart();\n          }\n        } else {\n          if (self.__interruptedAnimation || self.__isDragging) {\n            self.options.scrollingComplete();\n          }\n          self.scrollTo(self.__scrollLeft, self.__scrollTop, true, self.__zoomLevel);\n\n          // Directly signalize deactivation (nothing todo on refresh?)\n          if (self.__refreshActive) {\n            self.__refreshActive = false;\n            if (self.__refreshDeactivate) {\n              self.__refreshDeactivate();\n            }\n          }\n        }\n      }\n\n      // Fully cleanup list\n      self.__positions.length = 0;\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n      PRIVATE API\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Applies the scroll position to the content element\n     *\n     * @param left {Number} Left scroll position\n     * @param top {Number} Top scroll position\n     * @param animate {Boolean?false} Whether animation should be used to move to the new coordinates\n     */\n    __publish: function (left, top, zoom, animate) {\n      var self = this;\n\n      // Remember whether we had an animation, then we try to continue based on the current \"drive\" of the animation\n      var wasAnimating = self.__isAnimating;\n      if (wasAnimating) {\n        Animate.stop(wasAnimating);\n        self.__isAnimating = false;\n      }\n\n      if (animate && self.options.animating) {\n        // Keep scheduled positions for scrollBy/zoomBy functionality\n        self.__scheduledLeft = left;\n        self.__scheduledTop = top;\n        self.__scheduledZoom = zoom;\n\n        var oldLeft = self.__scrollLeft;\n        var oldTop = self.__scrollTop;\n        var oldZoom = self.__zoomLevel;\n\n        var diffLeft = left - oldLeft;\n        var diffTop = top - oldTop;\n        var diffZoom = zoom - oldZoom;\n\n        var step = function (percent, now, render) {\n          if (render) {\n            self.__scrollLeft = oldLeft + (diffLeft * percent);\n            self.__scrollTop = oldTop + (diffTop * percent);\n            self.__zoomLevel = oldZoom + (diffZoom * percent);\n\n            // Push values out\n            if (self.__callback) {\n              self.__callback(self.__scrollLeft, self.__scrollTop, self.__zoomLevel);\n            }\n          }\n        };\n\n        var verify = function (id) {\n          return self.__isAnimating === id\n        };\n\n        var completed = function (renderedFramesPerSecond, animationId, wasFinished) {\n          if (animationId === self.__isAnimating) {\n            self.__isAnimating = false;\n          }\n          if (self.__didDecelerationComplete || wasFinished) {\n            self.options.scrollingComplete();\n          }\n\n          if (self.options.zooming) {\n            self.__computeScrollMax();\n            if (self.__zoomComplete) {\n              self.__zoomComplete();\n              self.__zoomComplete = null;\n            }\n          }\n        };\n\n        // When continuing based on previous animation we choose an ease-out animation instead of ease-in-out\n        self.__isAnimating = Animate.start(step, verify, completed, self.options.animationDuration, wasAnimating ? easeOutCubic : easeInOutCubic);\n      } else {\n        self.__scheduledLeft = self.__scrollLeft = left;\n        self.__scheduledTop = self.__scrollTop = top;\n        self.__scheduledZoom = self.__zoomLevel = zoom;\n\n        // Push values out\n        if (self.__callback) {\n          self.__callback(left, top, zoom);\n        }\n\n        // Fix max scroll ranges\n        if (self.options.zooming) {\n          self.__computeScrollMax();\n          if (self.__zoomComplete) {\n            self.__zoomComplete();\n            self.__zoomComplete = null;\n          }\n        }\n      }\n    },\n\n    /**\n     * Recomputes scroll minimum values based on client dimensions and content dimensions.\n     */\n    __computeScrollMax: function (zoomLevel) {\n      var self = this;\n\n      if (zoomLevel == null) {\n        zoomLevel = self.__zoomLevel;\n      }\n\n      self.__maxScrollLeft = Math.max((self.__contentWidth * zoomLevel) - self.__clientWidth, 0);\n      self.__maxScrollTop = Math.max((self.__contentHeight * zoomLevel) - self.__clientHeight, 0);\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n      ANIMATION (DECELERATION) SUPPORT\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Called when a touch sequence end and the speed of the finger was high enough\n     * to switch into deceleration mode.\n     */\n    __startDeceleration: function (timeStamp) {\n      var self = this;\n\n      if (self.options.paging) {\n        var scrollLeft = Math.max(Math.min(self.__scrollLeft, self.__maxScrollLeft), 0);\n        var scrollTop = Math.max(Math.min(self.__scrollTop, self.__maxScrollTop), 0);\n        var clientWidth = self.__clientWidth;\n        var clientHeight = self.__clientHeight;\n\n        // We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.\n        // Each page should have exactly the size of the client area.\n        self.__minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth;\n        self.__minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight;\n        self.__maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth;\n        self.__maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;\n      } else {\n        self.__minDecelerationScrollLeft = 0;\n        self.__minDecelerationScrollTop = 0;\n        self.__maxDecelerationScrollLeft = self.__maxScrollLeft;\n        self.__maxDecelerationScrollTop = self.__maxScrollTop;\n      }\n\n      // Wrap class method\n      var step = function (percent, now, render) {\n        self.__stepThroughDeceleration(render);\n      };\n\n      // How much velocity is required to keep the deceleration running\n      var minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.001;\n\n      // Detect whether it's still worth to continue animating steps\n      // If we are already slow enough to not being user perceivable anymore, we stop the whole process here.\n      var verify = function () {\n        var shouldContinue = Math.abs(self.__decelerationVelocityX) >= minVelocityToKeepDecelerating || Math.abs(self.__decelerationVelocityY) >= minVelocityToKeepDecelerating;\n        if (!shouldContinue) {\n          self.__didDecelerationComplete = true;\n        }\n        return shouldContinue\n      };\n\n      var completed = function (renderedFramesPerSecond, animationId, wasFinished) {\n        self.__isDecelerating = false;\n        if (self.__didDecelerationComplete) {\n          self.options.scrollingComplete();\n        }\n\n        // Animate to grid when snapping is active, otherwise just fix out-of-boundary positions\n        self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);\n      };\n\n      // Start animation and switch on flag\n      self.__isDecelerating = Animate.start(step, verify, completed);\n    },\n\n    /**\n     * Called on every step of the animation\n     *\n     * @param inMemory {Boolean?false} Whether to not render the current step, but keep it in memory only. Used internally only!\n     */\n    __stepThroughDeceleration: function (render) {\n      var self = this;\n\n      //\n      // COMPUTE NEXT SCROLL POSITION\n      //\n\n      // Add deceleration to scroll position\n      var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;\n      var scrollTop = self.__scrollTop + self.__decelerationVelocityY;\n\n      //\n      // HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE\n      //\n\n      if (!self.options.bouncing) {\n        var scrollLeftFixed = Math.max(Math.min(self.__maxDecelerationScrollLeft, scrollLeft), self.__minDecelerationScrollLeft);\n        if (scrollLeftFixed !== scrollLeft) {\n          scrollLeft = scrollLeftFixed;\n          self.__decelerationVelocityX = 0;\n        }\n\n        var scrollTopFixed = Math.max(Math.min(self.__maxDecelerationScrollTop, scrollTop), self.__minDecelerationScrollTop);\n        if (scrollTopFixed !== scrollTop) {\n          scrollTop = scrollTopFixed;\n          self.__decelerationVelocityY = 0;\n        }\n      }\n\n      //\n      // UPDATE SCROLL POSITION\n      //\n\n      if (render) {\n        self.__publish(scrollLeft, scrollTop, self.__zoomLevel);\n      } else {\n        self.__scrollLeft = scrollLeft;\n        self.__scrollTop = scrollTop;\n      }\n\n      //\n      // SLOW DOWN\n      //\n\n      // Slow down velocity on every iteration\n      if (!self.options.paging) {\n        // This is the factor applied to every iteration of the animation\n        // to slow down the process. This should emulate natural behavior where\n        // objects slow down when the initiator of the movement is removed\n        var frictionFactor = 0.95;\n\n        self.__decelerationVelocityX *= frictionFactor;\n        self.__decelerationVelocityY *= frictionFactor;\n      }\n\n      //\n      // BOUNCING SUPPORT\n      //\n\n      if (self.options.bouncing) {\n        var scrollOutsideX = 0;\n        var scrollOutsideY = 0;\n\n        // This configures the amount of change applied to deceleration/acceleration when reaching boundaries\n        var penetrationDeceleration = self.options.penetrationDeceleration;\n        var penetrationAcceleration = self.options.penetrationAcceleration;\n\n        // Check limits\n        if (scrollLeft < self.__minDecelerationScrollLeft) {\n          scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;\n        } else if (scrollLeft > self.__maxDecelerationScrollLeft) {\n          scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;\n        }\n\n        if (scrollTop < self.__minDecelerationScrollTop) {\n          scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;\n        } else if (scrollTop > self.__maxDecelerationScrollTop) {\n          scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;\n        }\n\n        // Slow down until slow enough, then flip back to snap position\n        if (scrollOutsideX !== 0) {\n          if (scrollOutsideX * self.__decelerationVelocityX <= 0) {\n            self.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration;\n          } else {\n            self.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration;\n          }\n        }\n\n        if (scrollOutsideY !== 0) {\n          if (scrollOutsideY * self.__decelerationVelocityY <= 0) {\n            self.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration;\n          } else {\n            self.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration;\n          }\n        }\n      }\n    }\n  };\n\n  // Copy over members to prototype\n  for (var key in members) {\n    Scroller.prototype[key] = members[key];\n  }\n\n  var Scroller$1 = Scroller\n\n  var EasyScroller = function (content, render, options) {\n    this.content = content;\n    this.container = content.parentNode;\n    this.options = options || {};\n    this.render = render;\n\n    // create Scroller instance\n    var that = this;\n    this.scroller = new Scroller$1(function (left, top, zoom) {\n      that.render(left, top, zoom);\n    }, options);\n\n    // bind events\n    this.bindEvents();\n\n    // the content element needs a correct transform origin for zooming\n    this.content.style[EasyScroller.vendorPrefix + 'TransformOrigin'] = 'left top';\n\n    // reflow for the first time\n    this.reflow();\n  };\n\n  EasyScroller.prototype.reflow = function () {\n    // set the right scroller dimensions\n    this.scroller.setDimensions(this.container.clientWidth, this.container.clientHeight, this.content.offsetWidth, this.content.offsetHeight);\n\n    // refresh the position for zooming purposes\n    var rect = this.container.getBoundingClientRect();\n    this.scroller.setPosition(rect.left + this.container.clientLeft, rect.top + this.container.clientTop);\n  };\n\n  EasyScroller.prototype.bindEvents = function () {\n    var that = this;\n\n    // reflow handling\n    window.addEventListener('resize', function () {\n      that.reflow();\n    }, false);\n\n    // touch devices bind touch events\n    if ('ontouchstart' in window) {\n      this.container.addEventListener('touchstart', function (e) {\n        // Don't react if initial down happens on a form element\n        if (e.touches[0] && e.touches[0].target && e.touches[0].target.tagName.match(/input|textarea|select/i)) {\n          return\n        }\n\n        // reflow since the container may have changed\n        that.reflow();\n\n        that.scroller.doTouchStart(e.touches, e.timeStamp);\n      }, false);\n\n      this.container.addEventListener('touchmove', function (e) {\n        e.preventDefault();\n        that.scroller.doTouchMove(e.touches, e.timeStamp, e.scale);\n      }, false);\n\n      this.container.addEventListener('touchend', function (e) {\n        that.scroller.doTouchEnd(e.timeStamp);\n      }, false);\n\n      this.container.addEventListener('touchcancel', function (e) {\n        that.scroller.doTouchEnd(e.timeStamp);\n      }, false);\n\n      // non-touch bind mouse events\n    } else {\n      var mousedown = false;\n\n      this.container.addEventListener('mousedown', function (e) {\n        if (e.target.tagName.match(/input|textarea|select/i)) {\n          return\n        }\n\n        that.scroller.doTouchStart([{\n          pageX: e.pageX,\n          pageY: e.pageY\n        }], e.timeStamp);\n\n        mousedown = true;\n\n        // reflow since the container may have changed\n        that.reflow();\n\n        e.preventDefault();\n      }, false);\n\n      document.addEventListener('mousemove', function (e) {\n        if (!mousedown) {\n          return\n        }\n\n        that.scroller.doTouchMove([{\n          pageX: e.pageX,\n          pageY: e.pageY\n        }], e.timeStamp);\n\n        mousedown = true;\n      }, false);\n\n      document.addEventListener('mouseup', function (e) {\n        if (!mousedown) {\n          return\n        }\n\n        that.scroller.doTouchEnd(e.timeStamp);\n\n        mousedown = false;\n      }, false);\n\n      this.container.addEventListener('mousewheel', function (e) {\n        if (that.options.zooming) {\n          that.scroller.doMouseZoom(e.wheelDelta, e.timeStamp, e.pageX, e.pageY);\n          e.preventDefault();\n        }\n      }, false);\n    }\n  };\n\n  exports.Animate = Animate;\n  exports.Scroller = Scroller$1;\n  exports.EasyScroller = EasyScroller;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=scroller.js.map\n"]}